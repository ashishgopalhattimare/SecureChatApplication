package sample;

import com.jfoenix.controls.JFXListView;
import com.jfoenix.controls.JFXTextArea;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.chart.LineChart;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.*;
import javafx.scene.text.Font;
import javafx.stage.FileChooser;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.URL;
import java.nio.file.Files;
import java.security.*;
import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.RSAPublicKeySpec;
import java.util.ResourceBundle;

public class ServerController implements Initializable
{
    @FXML private TextField ipAddressField;
    @FXML private TextField portField;
    @FXML private Button connectButton;
    @FXML private JFXTextArea messageField;
    @FXML private Button serverButton;
    @FXML private JFXListView<HBox> listView;
    @FXML private ImageView attachButton;
    @FXML private BorderPane attachPane;
    @FXML private Button closeButton;

    public static final int IMAGE_SIZE = 70;
    public static final int GAP = 10;

    public static final double VERTICAL_GAP = 15.0;

    private ObjectOutputStream sOutput;
    private ObjectInputStream sInput;

    private boolean fileReceived;
    private boolean sendMessage;        // boolean to check whether client has sent message or not
    private String serverMessage;       // Store the message send by the server

    private ServerSocket serverSocket;  // ServerSocket used by client socket accept
    private Socket socket;
    private int port;                   // port used

    private Cipher keyDecipher;
    private Cipher ServerDecryptCipher;
    private Cipher ServerEncryptCipher;
    SecretKey AESKey;                   // Secret Key generated by the AES Algorithm

    int i = 0;                          // AES Key recieved (i = 0) or message recieved otherwise

    Message message;                    // Store message in serializable form
    Message toSend;                     // Message to be send to the other end

    static String IV = "AAAAAAAAAAAAAAAA";  // IvParameterSpec used in AES Algorithm

    private String recievedFileName;        // File Name Send to the Client

    private File fileHash;                  // verify whether the server and the client are connected, if exist

    private LineChart<?, ?> AESlineChartServer;
    private LineChart<?, ?> AESlineChartClient;
    private int messageIndex;

    @Override
    public void initialize(URL location, ResourceBundle resources) {

        i = 0;
        message = null;

        fileHash = new File(Constants.appFile);

        serverButton.setOnAction(this::serverActionEvent);
        connectButton.setOnAction(this::connectActionEvent);

        // Close the application when client exits the application
        closeButton.setOnAction(event -> {
            File file = new File(Constants.appFile);
            file.delete();
            System.exit(1);
        });

        attachButton.addEventHandler(MouseEvent.MOUSE_CLICKED, event -> {

            attachPane.setStyle(Constants.exitColor + Constants.attachBorder);

            FileChooser fileChooser = new FileChooser();
            File fileselect = fileChooser.showOpenDialog(null);

            if(fileselect != null && fileHash.exists()) {
                try {
                    // Send message to client that next byte stream would be a file byte form
                    constructEncryptedMessage(Constants.attachFile + " " + fileselect.getName());

                    // Sending file in byteform
                    byte[] fileByte = Files.readAllBytes(fileselect.toPath());
                    toSend = null;
                    toSend = new Message(fileByte);
                    sOutput.writeObject(toSend);

                    listView.getItems().add(constructAttachmentBox("Attachment Sent", Pos.CENTER_RIGHT, Constants.serverColor, Constants.messageBorder, Constants.serverImageLink, Constants.attachImageLink, true));
                }
                catch (Exception e) {
                    System.out.println("file transfer error");
                }// end if
            }
            else {
                System.out.println("file not valid");
            }// end if

            attachPane.setStyle(Constants.whiteColor + Constants.attachBorder);
        });

        messageField.setOnKeyPressed(this::keyPressed);

        connectButton.setStyle(Constants.exitColor+Constants.circleBorder);
        serverButton.setStyle(Constants.exitColor+Constants.circleBorder);


        listView.setFocusTraversable(false);
        listView.setVerticalGap(VERTICAL_GAP);
        listView.setExpanded(true);

        fileReceived = false;
        sendMessage = false;
    }

    /**
     * Method Name : serverConnect
     * Purpose - start the server side
     * @param port - port used
     */
    public void serverConnect(int port)
    {
        this.port = port;

        try {

            serverSocket = new ServerSocket(port);
            System.out.println("Reciever is listening on the port " + port);

            // Waiting for the serverSocket to accept client connection
            socket = serverSocket.accept();

            startServer();
        }
        catch(Exception e) {
            System.out.println("serverConnect error");
        }// end try/catch
    }// end serverConnect(int)

    /**
     * Method Name : startServer()
     * Purpose : method to start making connection for the server
     * return - void
     *
     * @throws IOException
     */
    public void startServer() throws IOException {

        listView.getItems().removeAll();

        ipAddressField.setDisable(true);
        connectButton.setDisable(true);
        portField.setDisable(true);

        ClientThread clientThread = new ClientThread(socket);

        clientThread.run();

        serverSocket.close();
    }// end startServer()

    private void keyPressed(KeyEvent keyEvent) {

        if(keyEvent.isShiftDown() && keyEvent.getCode().toString().equals("ENTER")) {
            try {
                serverMessage(messageField.getText());
                messageField.setText("");
            }
            catch (Exception e) {}
        }// end if
    }// end keyPressed(KeyEvent)

    /**
     * Method Name : serverActionEvent
     * purpose : Action to Execute when server attempts to send the message to other end
     * return - void
     *
     * @param actionEvent
     */
    private void serverActionEvent(ActionEvent actionEvent) {
        try {
            serverMessage(messageField.getText());
            messageField.setText("");
        }
        catch (Exception e) {}
    }// end serverActionEvent(ActionEvent)

    /**
     * Method Name : connectActionEvent
     * Putpose : attempt making connection to the client side
     * return - void
     *
     * @param actionEvent
     */
    private void connectActionEvent(ActionEvent actionEvent) {

        createHashFile();

        int port = Integer.parseInt(portField.getText());
        serverConnect(port);
    }// end connectActionEvent(ActionEvent)

    /**
     * Method Name : createHashFile
     * Purpose : create a checker file for the server and client
     */
    private void createHashFile() {
        try {
            fileHash.delete();
            fileHash.createNewFile();
        }
        catch (Exception e) {
            System.out.println("createHashFile error");
        }// end try/catch

    }// end createHashFile()

    /**
     * Method Name : constructAttachmentBox
     * Purpose : Construct an attachment box when file is transffered
     * @param message - attachment recieved or sent text
     * @param position - position of the display
     * @param userColor - box color
     * @param userBorder - box border
     * @param imageLink - sender or reciever imageLink
     * @param attachLink - attachment imageLink
     * @param right - right shift or left shift
     * @return - build Box
     */
    private HBox constructAttachmentBox(String message, Pos position, String userColor, String userBorder, String imageLink, String attachLink, boolean right)
    {
        HBox box = new HBox();
        box.setAlignment(position);

        AnchorPane space = new AnchorPane();
        space.setPrefSize(10,10);

        BorderPane imagePane = new BorderPane();

        // Image setup at the top of left side
        VBox imageFrame = new VBox();
        ImageView userImage = new ImageView(new Image(imageLink));
        userImage.setFitHeight(IMAGE_SIZE);
        userImage.setFitWidth(IMAGE_SIZE);

        imageFrame.setMinSize(IMAGE_SIZE + GAP,IMAGE_SIZE + GAP);
        imageFrame.setAlignment(Pos.TOP_CENTER);
        imageFrame.setStyle(userColor+Constants.circleBorder);
        imageFrame.getChildren().add(userImage);

        imagePane.setTop(imageFrame);

        VBox messagePanel = new VBox();
        messagePanel.setStyle(userColor+userBorder);

        FlowPane flowPane = new FlowPane();
        flowPane.setPadding(new Insets(GAP, GAP, GAP, GAP));

        ImageView attachImage = new ImageView(new Image(attachLink));
        attachImage.setFitHeight(IMAGE_SIZE - 10);
        attachImage.setFitWidth(IMAGE_SIZE - 10);

        Label messageLabel = new Label(message);
        messageLabel.setFont(new Font("San-serif", 18));

        if(right) {
            flowPane.setAlignment(Pos.BASELINE_RIGHT);

            flowPane.getChildren().addAll(messageLabel, attachImage);
            messagePanel.getChildren().add(flowPane);
            box.getChildren().addAll(messagePanel, space, imagePane);
        }
        else {
            flowPane.setAlignment(Pos.BASELINE_LEFT);

            flowPane.getChildren().addAll(attachImage, messageLabel);
            messagePanel.getChildren().addAll(flowPane);
            box.getChildren().addAll(imagePane, space, messagePanel);
        }// end if

        return box;
    }// end constructAttachmentBox(String, Pos, String, String, String, String, bool)

    /**
     * Method Name : constructMessageBox
     */
    private HBox constructMessageBox(String message, Pos position, String userColor, String userBorder, String imageLink, String user, boolean right)
    {
        HBox box = new HBox();
        box.setAlignment(position);

        AnchorPane space = new AnchorPane();
        space.setPrefSize(10,10);

        BorderPane imagePane = new BorderPane();

        VBox imageFrame = new VBox();
        ImageView userImage = new ImageView(new Image(imageLink));
        userImage.setFitHeight(IMAGE_SIZE);
        userImage.setFitWidth(IMAGE_SIZE);

        imageFrame.setMinSize(IMAGE_SIZE + GAP,IMAGE_SIZE + GAP);
        imageFrame.setAlignment(Pos.TOP_CENTER);
        imageFrame.setStyle(userColor+Constants.circleBorder);
        imageFrame.getChildren().add(userImage);

        imagePane.setTop(imageFrame);

        VBox messagePanel = new VBox();
        messagePanel.setStyle(userColor+userBorder);

        FlowPane flowPane = new FlowPane();
        flowPane.setPadding(new Insets(GAP, GAP, GAP, GAP));
        flowPane.setAlignment(position);

        Label messageLabel = new Label(message);
        messageLabel.setFont(new Font("San-serif", 18));

        flowPane.getChildren().add(messageLabel);
        messagePanel.getChildren().add(flowPane);

        if(right) {
            box.getChildren().addAll(messagePanel, space, imagePane);
        }
        else {
            box.getChildren().addAll(imagePane, space, messagePanel);
        }// end if

        return box;
    }// end contructMessageBox(String, Pos, String, String, String, String, boolean)

    /**
     * Method Name : serverMessage
     * Purpose : Display message from the server on the client's side
     * return - void
     *
     * @param message - server's message
     */
    private void serverMessage(String message) {

        try {
            if (message.length() > 0 && fileHash.exists()) {
                serverMessage = message;
                sendMessage = true;

                listView.getItems().add(constructMessageBox(message, Pos.CENTER_RIGHT, Constants.serverColor, Constants.messageBorder, Constants.serverImageLink, "SERVER", true));
            }// end if
        }
        catch(Exception e) {}
    }// end serverMessage(String)

    /**
     * Method Name : clientMessage
     * Purpose : Display message from the client on the client's side
     * return - void
     *
     * @param message - client's message
     */
    private void clientMessage(String message) {

        try {
            if (message.length() > 0 && fileHash.exists()) {
                listView.getItems().add(constructMessageBox(message, Pos.CENTER_LEFT, Constants.clientColor, Constants.messageBorder, Constants.clientImageLink, "CLIENT", false));
            }
        }
        catch(Exception e) {}
    }// end clientMessage(String)

    public void connectMouseEntered(MouseEvent mouseEvent) {
        connectButton.setStyle(Constants.enterColor+Constants.circleBorder);
    }

    public void connectMouseExited(MouseEvent mouseEvent) {
        connectButton.setStyle(Constants.exitColor+Constants.circleBorder);
    }

    public void serverMouseEntered(MouseEvent mouseEvent) {
        serverButton.setStyle(Constants.enterColor+Constants.circleBorder);
    }

    public void serverMouseExited(MouseEvent mouseEvent) {
        serverButton.setStyle(Constants.exitColor+Constants.circleBorder);
    }

    /**
     * Method Name : decryptAESKey
     * Purpose : decrypt AES SecretKey generated by the RSA Algorithm from the private.key file
     * return - void
     * @return
     */
    private void decryptAESKey(byte[] data)
    {
        SecretKey secretKey = null;     // SecretKey generated
        PrivateKey privateKey = null;   // privateKey used for the RSA Algorithm

        keyDecipher = null; //

        try {
            privateKey = readPrivateKeyfromFile("private.key"); // Read PrivateKey from the file
            keyDecipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");   // cipher to conduct
            keyDecipher.init(Cipher.DECRYPT_MODE, privateKey);          // specify cipher mode

            // Generate Secretkey from Cipher AESKey
            secretKey = new SecretKeySpec(keyDecipher.doFinal(data), "AES");

//            //System.out.println("AES key after decryption : " + secretKey);
            i = 1;

            AESKey = secretKey; // get AESKey SecretKey for AES Algorithm
        }
        catch(Exception e) {
            System.out.println("Server decryptAESKey error");
        }
    }// end decryptAESKey(byte[])

    /**
     * Method Name : readPrivateKeyFromFile
     * Purpose : get the PrivateKey from the file given
     * @param filename - private key file name
     *
     * @return - PrivateKey used by the RSA Algorithm
     * @throws IOException
     */
    private PrivateKey readPrivateKeyfromFile(String filename) throws IOException {

        FileInputStream fis = new FileInputStream(filename);
        ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(fis));

        PrivateKey privateKey = null;
        try {
            BigInteger modulo = (BigInteger)ois.readObject();   // get the modulo value of the PrivateKey
            BigInteger exponent = (BigInteger)ois.readObject(); // get the exponent value of the PrivateKey

            RSAPrivateKeySpec rsaPrivateKeySpec = new RSAPrivateKeySpec(modulo, exponent);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");

            // PrivateKey extracted
            privateKey = keyFactory.generatePrivate(rsaPrivateKeySpec);

            return privateKey;
        }
        catch(Exception e) {
            System.out.println("readPrivateKeyFromFile error");
        }
        finally {
            ois.close();
        }// end try/catch/finally

        return privateKey;

    }// end readPrivateKeyFromFile(String)

    /**
     * Method Name : readPublicKeyFromFile
     * @param filename - public key file
     * @return - PublicKey used for RSA Algorithm
     *
     * @throws IOException
     */
    private PublicKey readPublicKeyFromFile(String filename) throws IOException
    {
        FileInputStream in = new FileInputStream(filename);
        ObjectInputStream oin =  new ObjectInputStream(new BufferedInputStream(in));

        try {
            BigInteger m = (BigInteger) oin.readObject();   // modulo value of the PublicKey
            BigInteger e = (BigInteger) oin.readObject();   // exponent value of the PublicKey
            RSAPublicKeySpec keySpecifications = new RSAPublicKeySpec(m, e);

            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PublicKey publicKey = keyFactory.generatePublic(keySpecifications);

            return publicKey;
        } catch (Exception e) {
            throw new RuntimeException("Some error in reading public key", e);
        } finally {
            oin.close();
        }
    }// end readPublicKeyFromFile(String)

    /**
     * Method Name : decryptMessage
     * Purpose : AES Algorithmic Cipher Text to PlainText message
     * return - void
     *
     * @param data - AES cipherText in byte form
     */
    private void decryptMessage(byte[] data) {

        ServerDecryptCipher = null;

        try {

            // Cipher to conduct
            ServerDecryptCipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            // Spedicy cipher mode
            ServerDecryptCipher.init(Cipher.DECRYPT_MODE, AESKey, new IvParameterSpec(IV.getBytes()));

            long startTime = System.nanoTime();

            // AES cipher byte code to message byte code
            byte[] messageByte = ServerDecryptCipher.doFinal(data);

            // generated byte code to plainText message
            String inputMessage = new String(messageByte);

            long endTime = System.nanoTime();

            String[] inputArray = inputMessage.split(" ");

            if(inputArray[0].equals(Constants.attachFile)) {

                recievedFileName = inputArray[1];
                fileReceived = true;
                return;
            }// end if

            // Get the digitalSignature of the recieved message in byte form
            byte[] digitalByte = SaveKeyFile.ReadFile("clientDigitalSign.txt");

            // Check whether the message recieved by the digitalSignature of the send message from the other side
            boolean sameMessage = DigitalSign.verifySign(inputMessage, readPublicKeyFromFile("public.key"), digitalByte);

            // if both are same, display plaintext on both the side
            if(sameMessage == true && fileHash.exists()) {
//                System.out.println("Server : There is no middle man");
                clientMessage(inputMessage);
            }
            // else display message with warning of the middle man
            else {
//                System.out.println("Server : Middle main exists");
                clientMessage(inputMessage + "\n\n<< MESSAGE CHANGED >>");
            }// end if

            System.out.printf("DECRYPTION >> File size : %d bytes, time taken : %d nano seconds\n", messageByte.length, (int)(endTime - startTime));
        }
        catch(Exception e) {
            System.out.println("decryptMessage error");
        }// end try/catch
    }// end decryptMessage(byte[])

    /**
     * Method Name : encryptMessage
     * Purpose : encrypt Client's message with AES Algorithm
     * @param outputMessage - client's message
     * @return
     */
    private byte[] encryptMessage(String outputMessage) {

        ServerEncryptCipher = null;
        byte[] messageByte = null;

        try {

            // Cipher to conduct encryption
            ServerEncryptCipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            // specify cipher mode
            ServerEncryptCipher.init(Cipher.ENCRYPT_MODE, AESKey, new IvParameterSpec(IV.getBytes()));

            long startTime = System.nanoTime();

            // Cipher AES byte to plainText message byte
            messageByte = ServerEncryptCipher.doFinal(outputMessage.getBytes());

            long endTime = System.nanoTime();

            System.out.printf("ENCRYPTION >> File size : %d bytes, time taken : %d nano seconds\n", messageByte.length, (int)(endTime - startTime));
        }
        catch(Exception e) {
            System.out.println("encryptedMessage error");
        }// end try/catch

        return messageByte; // encrypted message in byte form
    }// end encryptMessage(String)

    /**
     * Method Name : contructEncryptedMessage
     * Purpose : Encrypt Message before sending
     *
     * @param outputMessage
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeyException
     * @throws SignatureException
     */
    private void constructEncryptedMessage(String outputMessage) throws IOException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
        // digitalSignature of the message
        byte[] digitalByte = DigitalSign.getSign(outputMessage, readPrivateKeyfromFile("private.key"));

        // Save digitalSignature in the file
        SaveKeyFile.WriteFile("serverDigitalSign.txt", digitalByte);

        // change sendMessage to false
        sendMessage = false;

        // Write message in the ObjectOutputStream
        toSend = null;
        toSend = new Message(encryptMessage(outputMessage));

        sOutput.writeObject(toSend);
        sOutput.reset();

    }// end contructEncrypteMessage(String)

    private class ClientThread extends Thread {

        private Socket socket;

        // Class Constructor
        public ClientThread(Socket socket) throws IOException {
            this.socket = socket;

            sOutput = new ObjectOutputStream(getSocket().getOutputStream());
            sInput = new ObjectInputStream(getSocket().getInputStream());

            new ListerClientMessage().start();
            new SendClientMessage().start();

        }// end ClientThread(Socket)

        public Socket getSocket() {
            return socket;
        }// end getSocket()
    }

    /**
     * Class Thread to send message to the client side
     */
    private class SendClientMessage extends Thread {

        public void run()
        {
            while(fileHash.exists()) {
                try {
                    sendMessage = false;
                    // loop until message is sent
                    while(sendMessage == false && fileHash.exists()) {
                        sleep(10);
                    }// end while()

                    if(fileHash.exists()) {
                        // message to be send
                        constructEncryptedMessage(serverMessage);

                        // write();
                    }// end if
                } catch(Exception e) {
                    break;
                } finally {
                    sendMessage = false;
                }// end try/catch/finally
            }// end while()
        }// end run()

        // Write message in the ObjetOutputStream
        public synchronized void write() throws IOException {
            sOutput.writeObject(toSend);
            sOutput.reset();
        }// end write()

    }// end SendClientMessage class

    /**
     * Thread to Recieve Message from Client side
     */
    private class ListerClientMessage extends Thread
    {
        public void run() {

            while(fileHash.exists()) {
                try {
                    message = (Message)sInput.readObject();
                }
                catch(Exception e) {
                    System.out.println("message read error");
                }// end try/catch

                /**
                 * Checking for whether key is send or message
                 * if i == 0 -> AES key is recieved
                 */
                if(i == 0) {
                    if(message.getData() != null) {
                        decryptAESKey(message.getData());
                        i++;
                    }
                }
                // if i != 0 -> Message key is recieved
                else {
                    try {
                        if(message.getData() != null) {
                            if(fileReceived == true) {
                                byte[] byteFile = message.getData();

                                int index = recievedFileName.indexOf('.');
                                String filename = recievedFileName.substring(0, index); // name of the file
                                String extension = recievedFileName.substring(index+1); // extension of the file

                                // current file
                                File file = new File(recievedFileName);
                                int counter = 0;

                                // Rename file of the current file exist
                                while(file.exists()) {
                                    recievedFileName = filename + "(" + counter + ")." + extension;
                                    file = new File(recievedFileName); // create new file

                                    counter++;
                                }// end while()

                                try {
                                    FileOutputStream fos = new FileOutputStream(recievedFileName);
                                    fos.write(byteFile);
                                    fileReceived = false;

                                    listView.getItems().add(constructAttachmentBox("Attachment Recieved", Pos.CENTER_LEFT, Constants.clientColor, Constants.messageBorder, Constants.clientImageLink, Constants.attachImageLink, false));

                                    System.out.println("File Recieved from Client");
                                } catch(Exception e) {}
                                finally {
                                    fileReceived = false;
                                }
                                fileReceived = false;
                            }
                            else {
                                decryptMessage(message.getData());
                            }// end if
                        }// end if
                    }
                    catch (Exception e) {
                        System.out.println("Listening Client Message error");
                    }// end try/catch
                }// end if
            }// end while()
        }// end run()
    }// end ListenClientMessage class

}// end ServerController