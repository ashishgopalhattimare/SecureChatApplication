package sample;

import com.jfoenix.controls.JFXListView;
import com.jfoenix.controls.JFXTextArea;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.chart.LineChart;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.*;
import javafx.scene.text.Font;
import javafx.stage.FileChooser;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.io.*;
import java.math.BigInteger;
import java.net.Socket;
import java.net.URL;
import java.nio.file.Files;
import java.security.*;
import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.RSAPublicKeySpec;
import java.util.ResourceBundle;

public class ClientController implements Initializable
{
    @FXML private TextField ipAddressField;
    @FXML private TextField portField;
    @FXML private Button connectButton;
    @FXML private JFXTextArea messageField;
    @FXML private Button clientButton;
    @FXML private JFXListView<HBox> listView;
    @FXML private ImageView attachButton;
    @FXML private BorderPane attachPane;
    @FXML private Button closeButton;

    public static final int IMAGE_SIZE = 70;
    public static final int GAP = 10;

    public static final double VERTICAL_GAP = 15.0;

    // Input/OutStream to get and get data from the other user
    private ObjectOutputStream sOutput;
    private ObjectInputStream sInput;

    private boolean fileReceived;   // check whether the file is recieved or not
    private boolean sendMessage;    // boolean to check whether client has sent message or not
    private String clientMessage;   // Store the message send by the client

    private Socket socket;          // Socket used
    private String server;          // Server Address
    private int port;               // port used

    private Cipher cipher2;         // Cipher used for AES Algorithm
    private Cipher cipher1;         // Cipher used for RSA Algorithm
    SecretKey AESkey;               // Secret Key generated by the AES Algorithm

    int i = 0;                      // AES Key received (i = 0) or message received otherwise

    Message message;                // Store message in serializable form
    Message toSend;                 // Message to be send to the other end

    static String IV = "AAAAAAAAAAAAAAAA";  // IvParameterSpec used in AES Algorithm

    private String recievedFileName;        // File Name Send to the Client

    private File fileHash;                  // verify whether the server and the client are connected, if exist

    private LineChart<?, ?> AESlineChartServer;
    private LineChart<?, ?> AESlineChartClient;
    private int messageIndex;

    @Override
    public void initialize(URL location, ResourceBundle resources) {

        fileHash = new File(Constants.appFile);

        clientButton.setOnAction(this::clientActionEvent);
        connectButton.setOnAction(this::connectActionEvent);

        // Close the application when client exits the application
        closeButton.setOnAction(event -> {
            File file = new File(Constants.appFile);
            file.delete();
            System.exit(1);
        });

        attachButton.addEventHandler(MouseEvent.MOUSE_CLICKED, event -> {

            attachPane.setStyle(Constants.exitColor + Constants.attachBorder);

            FileChooser fileChooser = new FileChooser();
            File fileselect = fileChooser.showOpenDialog(null);

            if(fileselect != null && fileHash.exists()) {
                try {
                    // Send message to client that next byte stream would be a file byte form
                    constructEncryptedMessage(Constants.attachFile + " " + fileselect.getName());

                    // Sending file in byteform
                    byte[] fileByte = Files.readAllBytes(fileselect.toPath());
                    toSend = null;
                    toSend = new Message(fileByte);
                    sOutput.writeObject(toSend);

                    listView.getItems().add(constructAttachmentBox("Attachment Sent", Pos.CENTER_RIGHT, Constants.serverColor, Constants.messageBorder, Constants.clientImageLink, Constants.attachImageLink, true));
                }
                catch (Exception e) {
                    System.out.println("file transfer error");
                }// end if
            }
            else {
                System.out.println("file not valid");
            }// end if

            attachPane.setStyle(Constants.whiteColor + Constants.attachBorder);
        });

        messageField.setOnKeyPressed(this::keyPressed);

        connectButton.setStyle(Constants.exitColor+Constants.circleBorder);
        clientButton.setStyle(Constants.exitColor+Constants.circleBorder);

        listView.setFocusTraversable(false);
        listView.setVerticalGap(VERTICAL_GAP);
        listView.setExpanded(true);

        fileReceived = false;
        sendMessage = false;

    }// end initialize(URL, ResourceBundle)

    /**
     * Method Name : clientConnect
     * Purpose : make client's connection to the server at given ip and port
     *
     * return - void
     * @param server - IP used for the connection
     * @param port - port used for the connection
     */
    private void clientConnect(String server, int port) {

        this.server = server;
        this.port = port;

        try {
            if(fileHash.exists()) {
                generateAESKey();
                socket = new Socket(server, port);

                startClient();
            }
            else {
                System.out.println("fileHash does not exist");
            }// end if
        }
        catch(Exception e) {
            System.out.println("clientConnect error");
        }// end try/catch

    }// end clientConnect(String, int)

    /**
     * Method Name : startClient
     * Purpose : start connection from the client side
     * return - void
     *
     * @throws IOException
     */
    private void startClient() throws IOException {

        ipAddressField.setDisable(true);
        connectButton.setDisable(true);
        portField.setDisable(true);

        listView.getItems().removeAll();
        //System.out.println("Connection accepted : "+ socket.getInetAddress() + " : " + socket.getPort());

        sInput = new ObjectInputStream(socket.getInputStream());
        sOutput = new ObjectOutputStream(socket.getOutputStream());

        new SendServerMessage().start();
        new ListenServerMessage().start();

    }// end startClient()

    /**
     * Method Name : keyPressed
     * Purpose : function to execute on keyPressed in messageField
     * return - void
     *
     * @param keyEvent
     */
    private void keyPressed(KeyEvent keyEvent) {

        if(keyEvent.isShiftDown() && keyEvent.getCode().toString().equals("ENTER")) {
            try {
                clientMessage(messageField.getText());
                messageField.setText("");
            }
            catch (Exception e) {}
        }// end if
    }// end keyPressed(KeyEvent)

    /**
     * Method Name : clientActionEvent
     * purpose : Action to Execute when client attempts to send the message to other end
     * return - void
     *
     * @param actionEvent
     */
    private void clientActionEvent(ActionEvent actionEvent) {
        try {
            clientMessage(messageField.getText());
            messageField.setText("");
        }
        catch (Exception e) {}

    }// end clientActionEvent(ActionEvent)

    /**
     * Method Name : connectActionEvent
     * Putpose : attempt making connection to the server side
     * return - void
     *
     * @param actionEvent
     */
    private void connectActionEvent(ActionEvent actionEvent) {

        String server = ipAddressField.getText();
        int port = Integer.parseInt(portField.getText());

        clientConnect(server, port);
    }// end connectActionEvent(ActionEvent)

    /**
     * Method Name : constructAttachmentBox
     * Purpose : Construct an attachment box when file is transffered
     * @param message - attachment recieved or sent text
     * @param position - position of the display
     * @param userColor - box color
     * @param userBorder - box border
     * @param imageLink - sender or reciever imageLink
     * @param attachLink - attachment imageLink
     * @param right - right shift or left shift
     * @return - build Box
     */
    private HBox constructAttachmentBox(String message, Pos position, String userColor, String userBorder, String imageLink, String attachLink, boolean right)
    {
        HBox box = new HBox();
        box.setAlignment(position);

        AnchorPane space = new AnchorPane();
        space.setPrefSize(10,10);

        BorderPane imagePane = new BorderPane();

        // Image setup at the top of left side
        VBox imageFrame = new VBox();
        ImageView userImage = new ImageView(new Image(imageLink));
        userImage.setFitHeight(IMAGE_SIZE);
        userImage.setFitWidth(IMAGE_SIZE);

        imageFrame.setMinSize(IMAGE_SIZE + GAP,IMAGE_SIZE + GAP);
        imageFrame.setAlignment(Pos.TOP_CENTER);
        imageFrame.setStyle(userColor+Constants.circleBorder);
        imageFrame.getChildren().add(userImage);

        imagePane.setTop(imageFrame);

        VBox messagePanel = new VBox();
        messagePanel.setStyle(userColor+userBorder);

        FlowPane flowPane = new FlowPane();
        flowPane.setPadding(new Insets(GAP, GAP, GAP, GAP));

        ImageView attachImage = new ImageView(new Image(attachLink));
        attachImage.setFitHeight(IMAGE_SIZE - 10);
        attachImage.setFitWidth(IMAGE_SIZE - 10);

        Label messageLabel = new Label(message);
        messageLabel.setFont(new Font("San-serif", 18));

        if(right) {
            flowPane.setAlignment(Pos.BASELINE_RIGHT);

            flowPane.getChildren().addAll(messageLabel, attachImage);
            messagePanel.getChildren().add(flowPane);
            box.getChildren().addAll(messagePanel, space, imagePane);
        }
        else {
            flowPane.setAlignment(Pos.BASELINE_LEFT);

            flowPane.getChildren().addAll(attachImage, messageLabel);
            messagePanel.getChildren().addAll(flowPane);
            box.getChildren().addAll(imagePane, space, messagePanel);
        }// end if

        return box;
    }// end constructAttachmentBox(String, Pos, String, String, String, String, bool)

    /**
     * Method Name : constructMessageBox
     */
    private HBox constructMessageBox(String message, Pos position, String userColor, String userBorder, String imageLink, String user, boolean right)
    {
        HBox box = new HBox();
        box.setAlignment(position);

        AnchorPane space = new AnchorPane();
        space.setPrefSize(10,10);

        BorderPane imagePane = new BorderPane();

        // Image setup at the top of left side
        VBox imageFrame = new VBox();
        ImageView userImage = new ImageView(new Image(imageLink));
        userImage.setFitHeight(IMAGE_SIZE);
        userImage.setFitWidth(IMAGE_SIZE);

        imageFrame.setMinSize(IMAGE_SIZE + GAP,IMAGE_SIZE + GAP);
        imageFrame.setAlignment(Pos.TOP_CENTER);
        imageFrame.setStyle(userColor+Constants.circleBorder);
        imageFrame.getChildren().add(userImage);

        imagePane.setTop(imageFrame);

        VBox messagePanel = new VBox();
        messagePanel.setStyle(userColor+userBorder);

        FlowPane flowPane = new FlowPane();
        flowPane.setPadding(new Insets(GAP, GAP, GAP, GAP));
        flowPane.setAlignment(position);

        Label messageLabel = new Label(message);
        messageLabel.setFont(new Font("San-serif", 18));

        flowPane.getChildren().add(messageLabel);
        messagePanel.getChildren().add(flowPane);

        if(right) {
            box.getChildren().addAll(messagePanel, space, imagePane);
        }
        else {
            box.getChildren().addAll(imagePane, space, messagePanel);
        }// end if

        return box;
    }// end contructMessageBox(String, Pos, String, String, String, String, boolean)

    /**
     * Method Name : serverMessage
     * Purpose : Display message from the server on the client's side
     * return - void
     *
     * @param message - server's message
     */
    private void serverMessage(String message) {
        try {
            if (message.length() > 0) {
                listView.getItems().add(constructMessageBox(message, Pos.CENTER_LEFT, Constants.clientColor, Constants.messageBorder, Constants.serverImageLink, "SERVER", false));
            }// end if
        }
        catch(Exception e) {}
    }// end serverMessage(String)

    /**
     * Method Name : clientMessage
     * Purpose : Display message from the client on the client's side
     * return - void
     *
     * @param message - client's message
     */
    private void clientMessage(String message) {

        try {
            if (message.length() > 0 && fileHash.exists()) {
                clientMessage = message;
                sendMessage = true;

                listView.getItems().add(constructMessageBox(message, Pos.CENTER_RIGHT, Constants.serverColor, Constants.messageBorder, Constants.clientImageLink, "CLIENT", true));
            }// end if
        }
        catch(Exception e) {}
    }// end clientMessage(String)

    public void connectMouseEntered(MouseEvent mouseEvent) {
        connectButton.setStyle(Constants.enterColor+Constants.circleBorder);
    }

    public void connectMouseExited(MouseEvent mouseEvent) {
        connectButton.setStyle(Constants.exitColor+Constants.circleBorder);
    }

    public void clientMouseEntered(MouseEvent mouseEvent) {
        clientButton.setStyle(Constants.enterColor+Constants.circleBorder);
    }

    public void clientMouseExited(MouseEvent mouseEvent) {
        clientButton.setStyle(Constants.exitColor+Constants.circleBorder);
    }

    /**
     * Method Name : generateAESKey
     * Purpose : generate AES SecretKey used for the message AES Encryption and Decryption (Symmmetric Key Crytopgraphy)
     * return - void
     */
    public void generateAESKey(){
        try {
            AESkey = null;
            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
            keyGenerator.init(128);
            AESkey = keyGenerator.generateKey();

            System.out.println("AES Key Generated : ");
        }
        catch (Exception e) {
            System.out.println("generateAESKey error");
        }// end try/catch

    }// end generateKey()

    /**
     * Method Name : encryptAESKey
     * Purpose : Encrypt AES SecretKey generated by the RSA Algorithm
     * return - void
     * @return
     */
    private byte[] encryptAESKey() {
        cipher1 = null;
        byte[] keyByte = null;

        try {
            // get RSA PublicKey from the file
            PublicKey publicKey = readPublicKeyFromFile("public.key");

            // Cipher to conduct encryption
            cipher1 = Cipher.getInstance("RSA/ECB/PKCS1Padding");
            // Cipher mode specify
            cipher1.init(Cipher.ENCRYPT_MODE, publicKey);

            long startTime = System.nanoTime(); // Start the time

            // This encrypted byte form of the AES SecretKey will the send to server side
            keyByte = cipher1.doFinal(AESkey.getEncoded());

            long endTime = System.nanoTime();   // end the time

            // Total time taken to encrypt the AES SecretKey
            long totalTime = endTime - startTime;

            System.out.println("Time taken by RSA Encrypted (nano second) : " + totalTime);

            i = 1;
        }
        catch(Exception e) {
            System.out.println("encryptAESKey error");
        }// end try/catch

        return keyByte; // Encrypted AES SecretKey in byte form by RSA Algorithm
    }// end encryptAESKey()

    /**
     * Method Name : encryptMessage
     * Purpose : encrypt Client's message with AES Algorithm
     * @param message - client's message
     * @return
     */
    private byte[] encryptMessage(String message) {

        cipher2 = null;
        byte[] encryptByte = null;

        try {
            // Cipher to conduct encryption
            cipher2 = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            // specify cipher mode
            cipher2.init(Cipher.ENCRYPT_MODE, AESkey, new IvParameterSpec(IV.getBytes()));

            long startTime = System.nanoTime(); // Start encryption time

            // Encrypted client message in byte form
            encryptByte = cipher2.doFinal(message.getBytes());

            long endTime = System.nanoTime();   // end encryption time

            // Time taken by the AES Algorithm to encrypt client message
            System.out.printf("ENCRYPTION >> File size : %d bytes, time taken : %d nano seconds\n", encryptByte.length, (int)(endTime - startTime));
        }
        catch(Exception e) {
            System.out.println("encryptMessage error");
        }// end try/conduct

        // return encrypted client message in byte form by AES Algorithm
        return encryptByte;
    }

    /**
     * Method Name : decryptMessage
     * Purpose : AES Algorithmic Cipher Text to PlainText message
     * return - void
     *
     * @param encryptedMessageByte - AES cipherText in byte form
     */
    private void decryptMessage(byte [] encryptedMessageByte)
    {
        cipher2 = null;
        try {

            // Cipher to conduct
            cipher2 = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            // Spedicy cipher mode
            cipher2.init(Cipher.DECRYPT_MODE, AESkey, new IvParameterSpec(IV.getBytes()));

            long startTime = System.nanoTime();

            // AES cipher byte code to message byte code
            byte[] messageByte = cipher2.doFinal(encryptedMessageByte);

            // generated byte code to plainText message
            String inputMessage = new String(messageByte);

            long endTime = System.nanoTime();

            String[] inputArray = inputMessage.split(" ");

            if(inputArray[0].equals(Constants.attachFile)) {

                recievedFileName = inputArray[1];
                fileReceived = true;
                return;
            }// end if

            // Get the digitalSignature of the recieved message in byte form
            byte[] digitalByte = SaveKeyFile.ReadFile("serverDigitalSign.txt");

            // Check whether the message recieved by the digitalSignature of the send message from the other side
            boolean sameMessage = DigitalSign.verifySign(inputMessage, readPublicKeyFromFile("public.key"), digitalByte);

            // if both are same, display plaintext on both the side
            if(sameMessage == true && fileHash.exists()) {
//                System.out.println("Server : There is no middle man");
                serverMessage(inputMessage);
            }
            // else display message with warning of the middle man
            else {
//                System.out.println("Server : Middle main exists");
                serverMessage(inputMessage + "\n\n<< MESSAGE CHANGED >>");
            }// end if

            System.out.printf("DECRYPTION >> File size : %d bytes, time taken : %d nano seconds\n", messageByte.length, (int)(endTime - startTime));
        }
        catch(Exception e) {
            System.out.println("decryptMessage error");
        }// end try/catch()
    }// end decryptMessage(byte[])

    /**
     * Method Name : readPrivateKeyFromFile
     * Purpose : get the PrivateKey from the file given
     * @param filename - private key file name
     *
     * @return - PrivateKey used by the RSA Algorithm
     * @throws IOException
     */
    private PrivateKey readPrivateKeyfromFile(String filename) throws IOException
    {
        FileInputStream fis = new FileInputStream(filename);
        ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(fis));

        PrivateKey privateKey = null;
        try {
            BigInteger modulo = (BigInteger)ois.readObject();   // get the modulo value of the PrivateKey
            BigInteger exponent = (BigInteger)ois.readObject(); // get the exponent value of the PrivateKey

            RSAPrivateKeySpec rsaPrivateKeySpec = new RSAPrivateKeySpec(modulo, exponent);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");

            // PrivateKey extracted
            privateKey = keyFactory.generatePrivate(rsaPrivateKeySpec);

            return privateKey;
        }
        catch(Exception e) {
            System.out.println("readPrivateKeyFromFile error");
        }
        finally {
            ois.close();
        }// end try/catch/finally

        return privateKey;

    }// end readPrivateKeyFromFile(String)

    /**
     * Method Name : readPublicKeyFromFile
     * @param filename - public key file
     * @return - PublicKey used for RSA Algorithm
     *
     * @throws IOException
     */
    private PublicKey readPublicKeyFromFile(String filename) throws IOException
    {
        FileInputStream in = new FileInputStream(filename);
        ObjectInputStream oin =  new ObjectInputStream(new BufferedInputStream(in));

        PublicKey publicKey = null;
        try {
            BigInteger m = (BigInteger) oin.readObject();   // modulo value of the PublicKey
            BigInteger e = (BigInteger) oin.readObject();   // exponent value of the PublicKey
            RSAPublicKeySpec keySpecifications = new RSAPublicKeySpec(m, e);

            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            publicKey = keyFactory.generatePublic(keySpecifications);

            return publicKey;
        } catch (Exception e) {
            throw new RuntimeException("Some error in reading public key", e);
        } finally {
            oin.close();
        }
    }// end readPublicKeyFromFile(String)

    /**
     * Method Name : contructEncryptedMessage
     * Purpose : Encrypt Message before sending
     *
     * @param outputMessage
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeyException
     * @throws SignatureException
     */
    private void constructEncryptedMessage(String outputMessage) throws IOException, NoSuchAlgorithmException, InvalidKeyException, SignatureException
    {
        // digitalSignature of the message
        byte[] digitalByte = DigitalSign.getSign(outputMessage, readPrivateKeyfromFile("private.key"));

        // Save digitalSignature in the file
        SaveKeyFile.WriteFile("clientDigitalSign.txt", digitalByte);

        // change sendMessage to false
        sendMessage = false;

        // Write message in the ObjectOutputStream
        toSend = null;
        toSend = new Message(encryptMessage(outputMessage));
        sOutput.writeObject(toSend);
//        sOutput.reset();

    }// end contructEncrypteMessage(String)

    /**
     * Class to Read message from Client side and Send message to Server Side
     */
    private class SendServerMessage extends Thread {

        public void run() {

            while(fileHash.exists()) {
                try {
                    if(i == 0) {
                        toSend = null;
                        toSend = new Message(encryptAESKey());
                        sOutput.writeObject(toSend);

                        i = 1;
                    }
                    else {
                        try {
                            sendMessage = false;

                            // loop until message is sent
                            while(sendMessage == false && fileHash.exists()) {
                                sleep(10);
                            }// end while()

                            if(fileHash.exists()) {
                                // message to be send
                                constructEncryptedMessage(clientMessage);
                            }// end if
                        } catch(Exception e) {
                            break;
                        } finally {
                            sendMessage = false;
                        }// end try/catch/finally
                    }// end if
                }
                catch(Exception e) {
                    System.out.println("SendServerMessage error");
                    break;
                }// end try/catch
            }// end while()
        }// end run()
    }// end SendServerMessage class

    /**
     * Thread to Recieve Message from Server side
     */
    private class ListenServerMessage extends Thread {

        public void run() {

            while(fileHash.exists()) {
                try {
                    sleep(10);
                    message = (Message)sInput.readObject();

                    if(fileReceived == true) {
                        byte[] byteFile = message.getData();

                        int index = recievedFileName.indexOf('.');
                        String filename = recievedFileName.substring(0, index); // name of the file
                        String extension = recievedFileName.substring(index+1); // extension of the file

                        // current file
                        File file = new File(recievedFileName);
                        int counter = 0;

                        // Rename file of the current file exist
                        while(file.exists()) {
                            recievedFileName = filename + "(" + counter + ")." + extension;
                            file = new File(recievedFileName); // create new file

                            counter++;
                        }// end while()

                        try {
                            FileOutputStream fos = new FileOutputStream(recievedFileName);
                            fos.write(byteFile);

                            listView.getItems().add(constructAttachmentBox("Attachment Recieved", Pos.CENTER_LEFT, Constants.clientColor, Constants.messageBorder, Constants.serverImageLink, Constants.attachImageLink, false));
                            System.out.println("File Recieved from Server");

                            fileReceived = false;

                        } catch(Exception e) {}
                        finally {
                            fileReceived = false;
                        }
                        fileReceived = false;
                    }
                    else {
                        decryptMessage(message.getData());
                    }// end if
                }
                catch(Exception e) {
                    System.out.println("Listen Server Message error");
                }// end try/catch
            }// end while()
        }// end run()
    }// end ListenServerMessage class

}// end ClientController